//! KDE Window decoration manager
//!
//! This interface allows a compositor to announce support for KDE's legacy server-side decorations.
//!
//! A client can use this protocol to request being decorated by a supporting compositor.
//!
//! ```no_run
//! # extern crate wayland_server;
//! #
//! use smithay::wayland::shell::legacy::decoration::{init_kde_decoration_manager, KdeDecorationRequest};
//! use wayland_protocols::misc::server_decoration::server::org_kde_kwin_server_decoration_manager::Mode;
//!
//! # let mut display = wayland_server::Display::new();
//!
//! init_kde_decoration_manager(
//!     &mut display,
//!     |request| match request {
//!         KdeDecorationRequest::Setup { manager } => manager.default_mode(Mode::Server),
//!         KdeDecorationRequest::RequestMode { decoration, mode, .. } => decoration.mode(mode),
//!         KdeDecorationRequest::NewToplevelDecoration { surface } => (),
//!         KdeDecorationRequest::Release => (),
//!     },
//!     None,
//! );

use std::{cell::RefCell, ops::Deref, rc::Rc};

use wayland_protocols::misc::server_decoration::server::{
    org_kde_kwin_server_decoration::{Mode, OrgKdeKwinServerDecoration, Request as ServerDecorationRequest},
    org_kde_kwin_server_decoration_manager::{
        OrgKdeKwinServerDecorationManager, Request as ServerDecorationManagerRequest,
    },
};
use wayland_server::protocol::wl_surface::WlSurface;
use wayland_server::{Display, Filter, Global, Main};

/// Events generated by the kde decoration manager.
#[derive(Debug)]
pub enum KdeDecorationRequest {
    /// Decoration manager setup completion.
    Setup {
        /// KDE decoration manager.
        manager: OrgKdeKwinServerDecorationManager,
    },
    /// A new toplevel decoration was instantiated.
    NewToplevelDecoration {
        /// KDE decoration object.
        decoration: OrgKdeKwinServerDecoration,
        /// The surface asosiated with the decoration.
        surface: WlSurface,
    },
    /// Informs the compositor that the client prefers the provided decoration mode.
    RequestMode {
        /// KDE decoration object.
        decoration: OrgKdeKwinServerDecoration,
        /// The surface asosiated with the decoration.
        surface: WlSurface,
        /// Desired mode.
        mode: Mode,
    },
    /// Decoration object was released.
    Release {
        /// The surface asosiated with the decoration.
        surface: WlSurface,
    },
}

/// Create a new KDE Decoration Manager global
///
/// A compositor can set the default mode for new clients at any time using
/// [`OrgKdeKwinServerDecorationManager::default_mode`]. For individual windows the decorations can
/// be set using [`OrgKdeKwinServerDecoration::mode`]. Both of these requests will cause the client
/// to respond with its desired mode using [`KdeDecorationRequest::RequestMode`], which then should
/// be acknowledged by the compositor using another [`OrgKdeKwinServerDecoration::mode`] event.
/// **It is up to the compositor to prevent feedback loops**, a client is free to ignore the
/// suggested decoration mode.
pub fn init_kde_decoration_manager<L, Impl>(
    display: &mut Display,
    implementation: Impl,
    _logger: L,
) -> Global<OrgKdeKwinServerDecorationManager>
where
    L: Into<Option<slog::Logger>>,
    Impl: FnMut(KdeDecorationRequest) + 'static,
{
    let callback = Rc::new(RefCell::new(implementation));
    display.create_global(
        1,
        Filter::new(
            move |(decoration_manager, _): (Main<OrgKdeKwinServerDecorationManager>, _), _, _| {
                (&mut *callback.borrow_mut())(KdeDecorationRequest::Setup {
                    manager: decoration_manager.deref().clone(),
                });

                let callback = callback.clone();
                decoration_manager.quick_assign(move |_, request, _| {
                    let (id, surface) = match request {
                        ServerDecorationManagerRequest::Create { id, surface } => (id, surface),
                        _ => return,
                    };

                    let decoration = id.deref().clone();
                    (&mut *callback.borrow_mut())(KdeDecorationRequest::NewToplevelDecoration {
                        decoration: decoration.clone(),
                        surface: surface.clone(),
                    });

                    let callback = callback.clone();
                    id.quick_assign(move |_, request, _| match request {
                        ServerDecorationRequest::RequestMode { mode } => {
                            (&mut *callback.borrow_mut())(KdeDecorationRequest::RequestMode {
                                decoration: decoration.clone(),
                                surface: surface.clone(),
                                mode,
                            });
                        }
                        ServerDecorationRequest::Release => {
                            (&mut *callback.borrow_mut())(KdeDecorationRequest::Release {
                                surface: surface.clone(),
                            });
                        }
                        _ => (),
                    });
                });
            },
        ),
    )
}
